#Протокол обмена информацией с 1С

- Установка: `composer require mavsan/laravel-1c-protocol`.
- Зарегистрировать сервис-провайдер в `config/app.php`
~~~
/*
 * Протокол обмена информацией с 1С
 */
Mavsan\LaProtocol\Providers\ProtocolProvider::class,
~~~
- Зарегистрировать пакет `Chumper/Zipper`, как указано в [документации](https://github.com/Chumper/Zipper):
~~~
// сервис-провайдер:
/*
 * работа с zip архивами
 */
Chumper\Zipper\ZipperServiceProvider::class,
// фасад
/*
 * Работа с zip архивами
 */
'Zipper' => Chumper\Zipper\Zipper::class,
~~~
- Опубликовать конфигурацию и изменить при необходимости: `php artisan vendor:publish --tag=la1CProtocolConfig`.
- Создать модель, которая будет обрабатывать пришедшие данные. Модель должна реализовывать интерфейс 
`\Mavsan\LaProtocol\Interfaces\Import`. Контроллер обмена в нужный момент создает эту модель и вызывает метод `import`, 
передавая туда полный путь к файлу, который необходимо обработать. Имя этого файла присылает 1С. В файле конфигурации 
прописать эту модель:
~~~
'catalogWorkModel'   => \App\Model::class,
~~~

##Как работает
Сервис провайдер регистрирует роут, с url, указанным в файле конфигурации. 1C стучится по этому ури и отсылает команды, 
описанные в [стандарте](http://v8.1c.ru/edi/edi_stnd/131/).

Для аутентификации соединения должен быть создан пользовать. Еги имя пользователя и пароль присылает 1C. Верификация 
пользователя производится как обычно: `Auth::attempt(['email' => $user, 'password' => $pass])`;

Контроллер обрабатывает эти команды, отсылая требуемые ответы. 

При приеме файлов подчищаются файлы предыдущих обменов, т.к. в протоколе не описана команда, что обмен завершен. Если 
файл zip - после получения он автоматически распаковывается.
 
##Как выполнить тестирование
При необходимости можно протестировать работу обмена, для этого в файле конфигурации пропишите:
~~~
// файл(ы) которые будут отосланы тестом для обработки, эмулируя отправку файлов 1С
'filesToSendTest'    => ['fileName.zip'],
// файл(ы) которые требуется обработать моделью после получения, эмулируя отправку команд обработки 1С
'filesToWorkTest'    => ['import.xml', 'offers.xml'],
~~~

PhpUnit должен использовать файл `phpunit.xml`, который идет с этим модулем, или в стандартных тестах в 
`phpunit.xml` необходимо прописать путь к тестам этого модуля:
~~~xml
<testsuites>
    ...
    <testsuite name="1с Protocol">
        <directory suffix="Test.php">./vendor/mavsan/laravel-1c-protocol/src/Tests/Unit</directory>
    </testsuite>
    ...
</testsuites>
~~~

В версию 0.0.8 в файл конфигурации добавлена возможность изменить имя пользователя и пароль для тестов. Если 
пользователя нет - он создаётся, но не удаляется (актуально для тестов на реальной базе, а не в памяти).

Таким образом можно протестировать протокол обмена, а не сам обмен, т.е. нельзя проверить что было добавлено в таблицы, 
верность логики обмена.

Для полного тестирования лучше всего будет в `/tests/Unit` создать свой тест, скопировав в него код из  
`\Mavsan\LaProtocol\Tests\Unit\CatalogTest` (к сожалению, унаследовать нельзя, т.к. в этом случае будет ошибка phpunit: 
'This test depends on ') в методе `testImport`, в котором выполняется отправка команды обработчику протокола - 
`type=catalig&mode=import`, свои проверки лучше всего добавлять после полной обработки каталога:

```php
public function testImport($session)
{
    ...
    
    foreach ($files as $file) {
        ...
        
        $response->assertSeeText('success');
    }
    
    // вот тут
    
    return $session;
}
```

### Обработка данных каталога
На определенном этапе 1С отсылает команду начать обработку присланных файлов. Контроллер создает экземпляр объекта модели, 
указанной в конфигурации (ключ конфигурации - `catalogWorkModel`) и вызывает метод `import($fileName)`, где 
`$fileName` - имя полный путь к файлу, который требуется обработать.

По мере работы этот метод должен возвращать:
 - `self::answerSuccess`, если обработка файла завершена;
 - `slef::answerProgress`, если требуется продолжить обработку файла (например большой объём данных);
 - `slef::answerFailure`, если произошла ошибка.
 
В не зависимости от ответа - будет вызван метод `getAnswerDetail()`, который должен вернуть детальный ответ или пустую 
строку. Например:
 - `обработано 500 записей из 100500`;
 - `ошибка: у товара указана группа, но такой группы нет`
 - `файл успешно обработан`
 
Если необходимо передать несколько строк - они должны быть разделены символов перевода каретки `\n`.